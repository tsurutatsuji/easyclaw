const express = require("express");
const { execSync } = require("child_process");
const crypto = require("crypto");
const fs = require("fs");
const path = require("path");
const Database = require("better-sqlite3");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const app = express();
app.post("/api/stripe/webhook", express.raw({ type: "application/json" }), handleStripeWebhook);
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(express.static("/home/ubuntu/easyclaw-api/public"));
app.get("/", (req, res) => { res.sendFile("/home/ubuntu/easyclaw-api/public/lp.html"); });
const JWT_SECRET = process.env.JWT_SECRET || crypto.randomBytes(32).toString("hex");
const UD = "/opt/easyclaw/users";
const OC = "/home/ubuntu/.npm-global/bin/openclaw";
const BASE_URL = process.env.BASE_URL || "http://49.212.148.254:3000";
const STRIPE_SECRET_KEY = process.env.STRIPE_SECRET_KEY || "";
const STRIPE_WEBHOOK_SECRET = process.env.STRIPE_WEBHOOK_SECRET || "";
const STRIPE_PRICES = { starter: process.env.STRIPE_PRICE_STARTER || "", standard: process.env.STRIPE_PRICE_STANDARD || "", pro: process.env.STRIPE_PRICE_PRO || "" };
let stripe = null;
function getStripe() { if (!stripe && STRIPE_SECRET_KEY) stripe = require("stripe")(STRIPE_SECRET_KEY); return stripe; }
const PLAN_LIMITS = { free: { maxBots: 0, label: "Free" }, starter: { maxBots: 1, label: "\u30b9\u30bf\u30fc\u30bf\u30fc\uff08\uffe5980/\u6708\uff09" }, standard: { maxBots: 3, label: "\u30b9\u30bf\u30f3\u30c0\u30fc\u30c9\uff08\uffe52,980/\u6708\uff09" }, pro: { maxBots: 10, label: "\u30d7\u30ed\uff08\uffe54,980/\u6708\uff09" } };
const db = new Database("/home/ubuntu/easyclaw-api/users.db");
db.exec("CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, email TEXT UNIQUE, password TEXT, createdAt TEXT)");
db.exec("CREATE TABLE IF NOT EXISTS deployments (id INTEGER PRIMARY KEY, userId TEXT, email TEXT, port INTEGER, model TEXT, status TEXT, createdAt TEXT)");
const addCol = (t, c, type, def) => { try { db.exec("ALTER TABLE " + t + " ADD COLUMN " + c + " " + type + " DEFAULT " + def); } catch(e) {} };
addCol("users", "plan", "TEXT", "free");
addCol("users", "stripeCustomerId", "TEXT", "NULL");
addCol("users", "stripeSubscriptionId", "TEXT", "NULL");
function auth(req, res, next) { const t = req.headers.authorization; if (!t) return res.status(401).json({ error: "\u30ed\u30b0\u30a4\u30f3\u5fc5\u9808" }); try { req.user = jwt.verify(t.replace("Bearer ", ""), JWT_SECRET); next(); } catch(e) { res.status(401).json({ error: "\u518d\u30ed\u30b0\u30a4\u30f3\u3057\u3066\u304f\u3060\u3055\u3044" }); } }
app.post("/api/register", (req, res) => { try { const { email, password } = req.body; if (!email || !password) return res.status(400).json({ error: "\u30e1\u30fc\u30eb\u3068\u30d1\u30b9\u30ef\u30fc\u30c9\u3092\u5165\u529b" }); if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) return res.status(400).json({ error: "正しいメールアドレスを入力してください（例: name@example.com）" }); if (password.length < 6) return res.status(400).json({ error: "\u30d1\u30b9\u30ef\u30fc\u30c9\u306f6\u6587\u5b57\u4ee5\u4e0a" }); const hash = bcrypt.hashSync(password, 10); db.prepare("INSERT INTO users (email, password, createdAt) VALUES (?,?,?)").run(email, hash, new Date().toISOString()); const token = jwt.sign({ email }, JWT_SECRET, { expiresIn: "7d" }); res.json({ success: true, token, email }); } catch(e) { if (e.message.includes("UNIQUE")) return res.status(400).json({ error: "\u767b\u9332\u6e08\u307f\u30e1\u30fc\u30eb" }); res.status(500).json({ error: e.message }); } });
app.post("/api/login", (req, res) => { const { email, password } = req.body; if (!email || !password) return res.status(400).json({ error: "\u30e1\u30fc\u30eb\u3068\u30d1\u30b9\u30ef\u30fc\u30c9\u3092\u5165\u529b" }); const user = db.prepare("SELECT * FROM users WHERE email=?").get(email); if (!user || !bcrypt.compareSync(password, user.password)) return res.status(401).json({ error: "\u30e1\u30fc\u30eb\u307e\u305f\u306f\u30d1\u30b9\u30ef\u30fc\u30c9\u304c\u9055\u3044\u307e\u3059" }); const token = jwt.sign({ email }, JWT_SECRET, { expiresIn: "7d" }); res.json({ success: true, token, email }); });
app.get("/api/subscription", auth, (req, res) => { const user = db.prepare("SELECT plan, stripeCustomerId, stripeSubscriptionId FROM users WHERE email=?").get(req.user.email); if (!user) return res.status(404).json({ error: "\u30e6\u30fc\u30b6\u30fc\u304c\u898b\u3064\u304b\u308a\u307e\u305b\u3093" }); const cnt = db.prepare("SELECT COUNT(*) as cnt FROM deployments WHERE email=?").get(req.user.email).cnt; const limits = PLAN_LIMITS[user.plan] || PLAN_LIMITS.free; res.json({ plan: user.plan || "free", planLabel: limits.label, maxBots: limits.maxBots, currentBots: cnt, canDeploy: cnt < limits.maxBots, hasSubscription: !!user.stripeSubscriptionId }); });
app.post("/api/stripe/checkout", auth, async (req, res) => { try { const s = getStripe(); if (!s) return res.status(500).json({ error: "Stripe\u672a\u8a2d\u5b9a\u3067\u3059" }); const { plan } = req.body; const priceId = STRIPE_PRICES[plan]; if (!priceId) return res.status(400).json({ error: "\u7121\u52b9\u306a\u30d7\u30e9\u30f3\u3067\u3059" }); const user = db.prepare("SELECT * FROM users WHERE email=?").get(req.user.email); let customerId = user.stripeCustomerId; if (!customerId) { const customer = await s.customers.create({ email: req.user.email }); customerId = customer.id; db.prepare("UPDATE users SET stripeCustomerId=? WHERE email=?").run(customerId, req.user.email); } if (user.stripeSubscriptionId) { return res.status(400).json({ error: "\u65e2\u306b\u30b5\u30d6\u30b9\u30af\u304c\u3042\u308a\u307e\u3059", redirect: "portal" }); } const session = await s.checkout.sessions.create({ customer: customerId, mode: "subscription", payment_method_types: ["card"], subscription_data: { trial_period_days: 1 }, line_items: [{ price: priceId, quantity: 1 }], success_url: BASE_URL + "/app.html?payment=success", cancel_url: BASE_URL + "/app.html?payment=cancelled", metadata: { email: req.user.email, plan } }); res.json({ url: session.url }); } catch(e) { console.error("Stripe checkout error:", e.message); res.status(500).json({ error: "\u6c7a\u6e08\u30da\u30fc\u30b8\u306e\u4f5c\u6210\u306b\u5931\u6557" }); } });
app.post("/api/stripe/portal", auth, async (req, res) => { try { const s = getStripe(); if (!s) return res.status(500).json({ error: "Stripe\u672a\u8a2d\u5b9a" }); const user = db.prepare("SELECT stripeCustomerId FROM users WHERE email=?").get(req.user.email); if (!user || !user.stripeCustomerId) return res.status(400).json({ error: "\u30b5\u30d6\u30b9\u30af\u304c\u3042\u308a\u307e\u305b\u3093" }); const session = await s.billingPortal.sessions.create({ customer: user.stripeCustomerId, return_url: BASE_URL + "/app.html" }); res.json({ url: session.url }); } catch(e) { res.status(500).json({ error: "\u30dd\u30fc\u30bf\u30eb\u4f5c\u6210\u5931\u6557" }); } });
async function handleStripeWebhook(req, res) { const s = getStripe(); if (!s) return res.status(400).send("Stripe not configured"); let event; try { if (STRIPE_WEBHOOK_SECRET) { event = s.webhooks.constructEvent(req.body, req.headers["stripe-signature"], STRIPE_WEBHOOK_SECRET); } else { event = JSON.parse(req.body); } } catch(e) { console.error("Webhook sig error:", e.message); return res.status(400).send("Webhook Error"); } console.log("[Stripe]", event.type); try { switch (event.type) { case "checkout.session.completed": { const session = event.data.object; const email = session.metadata && session.metadata.email || session.customer_email; const plan = session.metadata && session.metadata.plan; if (email && plan) { db.prepare("UPDATE users SET plan=?, stripeCustomerId=?, stripeSubscriptionId=? WHERE email=?").run(plan, session.customer, session.subscription, email); console.log("[Activated] " + email + " -> " + plan); } break; } case "customer.subscription.updated": { const sub = event.data.object; const user = db.prepare("SELECT * FROM users WHERE stripeCustomerId=?").get(sub.customer); if (!user) break; const priceId = sub.items.data[0] && sub.items.data[0].price && sub.items.data[0].price.id; let newPlan = "free"; if (priceId === STRIPE_PRICES.starter) newPlan = "starter"; else if (priceId === STRIPE_PRICES.standard) newPlan = "standard"; else if (priceId === STRIPE_PRICES.pro) newPlan = "pro"; if (!sub.cancel_at_period_end) { db.prepare("UPDATE users SET plan=?, stripeSubscriptionId=? WHERE email=?").run(newPlan, sub.id, user.email); console.log("[Updated] " + user.email + " -> " + newPlan); } break; } case "customer.subscription.deleted": { const sub2 = event.data.object; const user2 = db.prepare("SELECT * FROM users WHERE stripeCustomerId=?").get(sub2.customer); if (user2) { db.prepare("UPDATE users SET plan=?, stripeSubscriptionId=NULL WHERE email=?").run("free", user2.email); const deps = db.prepare("SELECT * FROM deployments WHERE email=?").all(user2.email); for (const d of deps) { try { execSync("sudo systemctl stop easyclaw-" + d.userId); db.prepare("UPDATE deployments SET status=? WHERE userId=?").run("stopped", d.userId); } catch(e) {} } console.log("[Cancelled] " + user2.email + " -> free"); } break; } case "invoice.payment_failed": { const inv = event.data.object; const user3 = db.prepare("SELECT * FROM users WHERE stripeCustomerId=?").get(inv.customer); if (user3) console.log("[Payment failed] " + user3.email); break; } } } catch(e) { console.error("Webhook error:", e.message); } res.json({ received: true }); }
app.post("/api/deploy", auth, (req, res) => { try { return res.status(503).json({error:"セキュリティ強化のため一時停止中です"}); const user = db.prepare("SELECT plan FROM users WHERE email=?").get(req.user.email); const plan = user && user.plan || "free"; const limits = PLAN_LIMITS[plan] || PLAN_LIMITS.free; const cnt = db.prepare("SELECT COUNT(*) as cnt FROM deployments WHERE email=?").get(req.user.email).cnt; if (cnt >= limits.maxBots) { if (limits.maxBots === 0) return res.status(403).json({ error: "\u30c7\u30d7\u30ed\u30a4\u306b\u306f\u30d7\u30e9\u30f3\u304c\u5fc5\u8981\u3067\u3059", code: "NO_PLAN" }); return res.status(403).json({ error: limits.label + "\u306e\u4e0a\u9650\u3067\u3059", code: "LIMIT_REACHED" }); } const { userId, apiProvider, apiKey, model, discordToken, discordUserId } = req.body; if (!userId || !apiKey || !discordToken || !discordUserId) return res.status(400).json({ error: "\u5168\u9805\u76ee\u5165\u529b\u5fc5\u9808" }); const users = fs.existsSync(UD) ? fs.readdirSync(UD) : []; const port = 20001 + users.length; const od = path.join(UD, userId, ".openclaw"); const ad = path.join(od, "agents/main/agent"); const cd = path.join(od, "credentials"); const wd = path.join(od, "workspace"); fs.mkdirSync(ad, { recursive: true }); fs.mkdirSync(cd, { recursive: true }); fs.mkdirSync(wd, { recursive: true }); const gt = crypto.randomBytes(24).toString("hex"); fs.writeFileSync(path.join(ad, "auth.json"), JSON.stringify({ [apiProvider]: { type: "api_key", key: apiKey } })); fs.writeFileSync(path.join(ad, "auth-profiles.json"), JSON.stringify({ version: 1, profiles: { [apiProvider + ":default"]: { type: "api_key", provider: apiProvider, key: apiKey } }, lastGood: { [apiProvider]: apiProvider + ":default" } })); fs.writeFileSync(path.join(od, "openclaw.json"), JSON.stringify({ auth: { profiles: { [apiProvider + ":default"]: { provider: apiProvider, mode: "api_key" } } }, agents: { defaults: { model: { primary: model }, workspace: wd, compaction: { mode: "safeguard" }, maxConcurrent: 4 } }, channels: { discord: { enabled: true, token: discordToken, groupPolicy: "allowlist", guilds: {} } }, gateway: { port: port, mode: "local", bind: "loopback", auth: { mode: "token", token: gt } }, plugins: { entries: { discord: { enabled: true } } } })); fs.writeFileSync(path.join(cd, "discord-allowFrom.json"), JSON.stringify({ version: 1, allowFrom: [discordUserId] })); execSync("sudo chown -R ubuntu:ubuntu " + path.join(UD, userId)); const sn = "easyclaw-" + userId; const sc = "[Unit]\nDescription=EasyClaw - " + userId + "\nAfter=network.target\n\n[Service]\nType=simple\nUser=ubuntu\nEnvironment=OPENCLAW_CONFIG_PATH=" + path.join(od, "openclaw.json") + "\nExecStart=" + OC + " gateway --port " + port + " --allow-unconfigured\nRestart=always\nRestartSec=5\n\n[Install]\nWantedBy=multi-user.target"; fs.writeFileSync("/etc/systemd/system/" + sn + ".service", sc); execSync("sudo systemctl daemon-reload"); execSync("sudo systemctl enable " + sn); execSync("sudo systemctl start " + sn); db.prepare("INSERT INTO deployments (userId,email,port,model,status,createdAt) VALUES (?,?,?,?,?,?)").run(userId, req.user.email, port, model, "active", new Date().toISOString()); res.json({ success: true, message: "\u30c7\u30d7\u30ed\u30a4\u5b8c\u4e86", userId: userId, port: port, model: model }); } catch(e) { res.status(500).json({ error: e.message }); } });
app.get("/api/my-deployments", auth, (req, res) => { const deps = db.prepare("SELECT * FROM deployments WHERE email=?").all(req.user.email); if (!deps.length) return res.json({ exists: false, deployments: [] }); const result = deps.map(function(d) { let running = false; try { running = execSync("sudo systemctl is-active easyclaw-" + d.userId).toString().trim() === "active"; } catch(e) {} return Object.assign({}, d, { running: running }); }); res.json({ exists: true, deployments: result }); });
app.get("/api/my-deployment", auth, (req, res) => { const dep = db.prepare("SELECT * FROM deployments WHERE email=?").get(req.user.email); if (!dep) return res.json({ exists: false }); try { const s = execSync("sudo systemctl is-active easyclaw-" + dep.userId).toString().trim(); res.json({ exists: true, userId: dep.userId, email: dep.email, port: dep.port, model: dep.model, status: dep.status, createdAt: dep.createdAt, running: s === "active" }); } catch(e) { res.json({ exists: true, userId: dep.userId, email: dep.email, port: dep.port, model: dep.model, status: dep.status, createdAt: dep.createdAt, running: false }); } });
app.post("/api/stop/:userId", auth, (req, res) => { try { execSync("sudo systemctl stop easyclaw-" + req.params.userId); db.prepare("UPDATE deployments SET status=? WHERE userId=?").run("stopped", req.params.userId); res.json({ message: "\u505c\u6b62" }); } catch(e) { res.status(500).json({ error: "\u5931\u6557" }); } });
app.post("/api/delete/:userId", auth, (req, res) => { const u = req.params.userId; try { execSync("sudo systemctl stop easyclaw-" + u); execSync("sudo systemctl disable easyclaw-" + u); fs.unlinkSync("/etc/systemd/system/easyclaw-" + u + ".service"); execSync("sudo systemctl daemon-reload"); execSync("rm -rf " + path.join(UD, u)); db.prepare("DELETE FROM deployments WHERE userId=?").run(u); res.json({ message: "\u524a\u9664\u5b8c\u4e86" }); } catch(e) { res.status(500).json({ error: "\u5931\u6557" }); } });
app.post("/api/update-bot/:botId", auth, async (req, res) => { try { var botId = req.params.botId; var dep = db.prepare("SELECT * FROM deployments WHERE userId = ? AND email = ?").get(botId, req.user.email); if (!dep) return res.status(403).json({ error: "このBotを変更する権限がありません" }); var ocDir = path.join("/opt/easyclaw/users", botId, ".openclaw"); var ocPath = path.join(ocDir, "openclaw.json"); var authPath = path.join(ocDir, "agents/main/agent/auth.json"); var authProfPath = path.join(ocDir, "agents/main/agent/auth-profiles.json"); var credPath = path.join(ocDir, "credentials/discord-allowFrom.json"); if (!fs.existsSync(ocPath)) return res.status(404).json({ error: "Bot設定ファイルが見つかりません" }); if (req.body.apiKey) { var authJson = JSON.parse(fs.readFileSync(authPath, "utf8")); var provider = Object.keys(authJson)[0]; authJson[provider].key = req.body.apiKey; fs.writeFileSync(authPath, JSON.stringify(authJson)); var profJson = JSON.parse(fs.readFileSync(authProfPath, "utf8")); var profKey = Object.keys(profJson.profiles)[0]; profJson.profiles[profKey].key = req.body.apiKey; fs.writeFileSync(authProfPath, JSON.stringify(profJson)); } if (req.body.discordToken) { var ocJson = JSON.parse(fs.readFileSync(ocPath, "utf8")); ocJson.channels.discord.token = req.body.discordToken; fs.writeFileSync(ocPath, JSON.stringify(ocJson)); } if (req.body.discordUserId) { var credJson = JSON.parse(fs.readFileSync(credPath, "utf8")); credJson.allowFrom = [req.body.discordUserId]; fs.writeFileSync(credPath, JSON.stringify(credJson)); } try { require("child_process").execSync("sudo systemctl restart easyclaw-" + botId, { timeout: 10000 }); } catch(e) {} res.json({ success: true, message: "設定を更新しBotを再起動しました" }); } catch(e) { console.error("Update bot error:", e.message); res.status(500).json({ error: "設定の更新に失敗: " + e.message }); } });

app.listen(3000, "0.0.0.0", () => { console.log("EasyClaw API running on port 3000"); console.log("Stripe:", STRIPE_SECRET_KEY ? "configured" : "NOT configured"); });
